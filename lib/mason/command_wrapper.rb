module Mason
  
  require 'open3'
  

  class CommandWrapper
    
    attr_accessor :command, # the whole command string with args, e.g. 'ls -al /foo'
                  :working_directory, 
                  :expected_exit_status,
                  :raise_on_bad_exit,
                  :exit_status,
                  :stdout,
                  :stderr,
                  :start_time,
                  :end_time
    
    def initialize(command = nil)
      @command              = command
      @working_directory    = Dir.pwd
      @expected_exit_status = 0
      @raise_on_bad_exit    = false # this defaulted true for years, but I was wrong
      @start_time           = nil
      @end_time             = nil
      @stdout               = nil
      @stderr               = nil
      @exit_status          = nil

      @interactive          = nil
    end

    # True if the receiver is expected to interact with a *human*. CommandWrapper instances are intended to support both direct use on the command line, and being driven from code or unattended scripts. If interactive is false, the calling code can still use a block to decide how to handle the result of the command. But if interactive is true, then the command will assume it is talking to a person, and write to stdout and read from stdin to resolve ambiguities and errors. If not explicitly set, the imperfect heuristic STDIN.tty? is used.
    def interactive?
      @interactive.nil? ? STDIN.tty? : @interactive
    end


    # Explicitly set whether receiver should run in interactive mode.
    def interactive=(value)
      @interactive = value
    end



    def proceed_retry_or_fail?
      if successful?
        result = :proceed

      elsif interactive?
        result = ask_user_whether_to_proceed_retry_or_fail
        while result == :retry
          retry_run
          result = ask_user_whether_to_proceed_retry_or_fail
        end

      else
        result = :fail
      end

      return result
    end

    # True if the command was successful, OR if the error/warning generated by the command was acknowledged and proceeding to the next step is allowed (either by a human in interactive mode, or a block supplied in non-interactive mode.)
    def ok?
      successful? || (proceed_retry_or_fail? == :proceed)
    end


    def run
      if interactive?
        puts "RUN: #{self.to_s :short }" # FIXME: this is annoying; it's just for now
      end

      @exit_status, @stdout, @stderr, @start_time, @end_time = run_command(@command)
      
      if @raise_on_bad_exit && (@exit_status != @expected_exit_status)
        raise UnexpectedExitStatusError.new("#{to_s :short}: expected #{@expected_exit_status} but got #{@exit_status}")
      end
    end


    def retry_run
      #FIXME : nil out run values before re-running
      run
    end
    
    
    def run_command(cmd_str)
      # run cmd in the shell, wait for exit, and return exit_status, stdout_output, stderr_output, start_time, end_time
      # e.g. exit_status, stdout_output, stderr_output = run_command 'ls -l /'

      if [nil, ''].include? cmd_str
        raise InvalidCommandError.new("invalid command: #{cmd_str}")
      end

      start_time = Time.now

      # Mason 2010-10-17: here is one way to run a one shot command line tool
      # subprocess in Ruby 1.9. The read calls block until the subprocess exits,
      # so when you want get fancy and communicate with the subprocess then
      # this isn't what you need. Also, there's no mechanism yet to have a timeout or
      # interrupt a task that is e.g. stuck waiting for input or otherwise infinite.


        stdin, stdout, stderr, wait_thr = Open3.popen3(cmd_str + ";")
          # why the semicolon? See http://stackoverflow.com/questions/26040249/why-does-open3-popen3-return-wrong-error-when-executable-is-missing
          # Short answer: forces cmd_str to go to shell, not kernel, preventing ENOENT exception in common case and giving us error exit_status instead.
          #
          # Otherwise:
          #
          # begin
          #   stdin, stdout, stderr, wait_thr = Open3.popen3(cmd_str + ";")
          # rescue Errno::ENOENT => kernel_err
          #   # puts "ENOENT: no such file or directory: #{kernel_err.errno}"
          #
          #   raise kernel_err
          #     # Re-raise this for now, while I decide what to do.
          #     # Maybe raise InvalidCommandError? Or have mechanism to suppress?
          # end

      # pid = wait_thr[:pid]  # pid of the started process.
      # puts "Execute command: " + cmd
      # puts "pid: " + pid.to_s

      stdout_output = stdout.read
      stderr_output = stderr.read
        # those block until exit, so after this line subprocess is done

      status = wait_thr.value  # Process::Status object returned.

      stdin.close  # per docs, stdin, stdout and stderr should be closed in this form.
      stdout.close # dunno if that is really necessary in this use case but it does
      stderr.close # not seem to hurt...

      exit_status = status.exitstatus
      end_time    = Time.now
      
      return exit_status, stdout_output, stderr_output, start_time, end_time
    end

    def self.run_command(cmd_str)
      cw = self.new cmd_str
      cw.run
      return cw
    end

    def successful?
      exit_status == expected_exit_status
    end

    def failed?
      exit_status != expected_exit_status
    end
    

    def to_s(style = :short)
      result = "#{self.class.name}: #{@command}\n"

      if style == :full
        result += "exit_status: #{exit_status}\n"
        result += "stdout: #{stdout}\n" unless stdout.nil? || stdout.empty?
        result += "stderr: #{stderr}\n" unless stderr.nil? || stderr.empty?
      end

      result
    end

    # Returns 
    def ask_user_whether_to_proceed_retry_or_fail
      puts " * "
      puts " * #{self.to_s :short}"
      puts " * "
      puts " * DO YOU WANT TO PROCEED?"
      puts " * "
      puts " * This command encountered an error. Should we proceed, ignoring this error?"
      puts " * "
      puts " * [y]es, [n]o, [r]etry "

      answer = STDIN.gets.chomp.downcase

      if answer.start_with? 'y'
        return :proceed
      elsif answer.start_with? 'n'
        return :fail
      elsif answer.start_with? 'r'
        return :retry
      else
        puts " * "
        puts " * I CANNOT GROK THAT INPUT. PLEASE TRY AGAIN: "
        puts " * "
        return ask_user_whether_to_proceed_retry_or_fail
      end

    end


    class InvalidCommandError < StandardError
    end
    
    class UnexpectedExitStatusError < StandardError
    end
    
  end # CommandWrapper class
  
end # Mason module
